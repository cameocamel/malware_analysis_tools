#!/usr/bin/env python

# Even when a .NET malware is deobfuscated, it can sometimes take time to identify the class and 
# method in which the config can be found, especially when there is no obvious config-related 
# method called near the entry point and there are a large number of classes. This script 
# attempts to automatically identify which classes (or types) and/or methods the config is most 
# likely to be located at, based on a variety of strategies:
#      1. The number of methods in a type that contain keywords often associated with config-related 
# methods. This method has the drawback that a lot of crypto-related functions share these 
# keywords, resulting in a lot of false positive results.
#      2. The same as 1 except targeting methods rather than types.
#      3. The proportion of instructions in each method that are ldstr instructions, which is often 
# used in config-related code. The ldstr instruction pushes an object reference (type O) to a new 
# string object representing the specific string literal stored in the metadata. My understanding 
# is that the ldstr instruction is used when a string variable is assigned a value.
#      4 - Same as 3 except with ldtoken instructions. ldtoken converts a metadata token to its 
# runtime representation. I believe this instruction occurs when a structure such as an array is 
# used.
# 
# There are functions that implement each of the above strategies, as well as a function to 
# obtain outliers fom the results, and a function create bar charts based on the results. The 
# idea is that any high-value outliers (e.g., for method 3, a method that inclues a much higher 
# proportion of ldstr instruction than other methods in the assembly) are more likely to include 
# config-related code. The strategies are ordered by the proportion of outliers,  with the 
# highest first. Only outliers are printed to stdout, while the top ten results for each strategy 
# are shown in the bar charts.

# Note that dnlib.dll can be obtained by downloading this repository
# (https://github.com/0xd4d/dnlib) and running 'dot net build' - the dll will be found under
# dnlib-master\Examples\bin\Debug\net45\dnlib.dll

# The other requirements can be installed with 'pip install dotnetfile numpy pandas matplotlib clr'
# Parse arguments
import argparse
parser = argparse.ArgumentParser(description='Attempt to locate types and/or methods that contain the config.')
parser.add_argument('-f', '--file', required=True, help='Path to the file to analyse.')
parser.add_argument('-d', '--dnlib', required=False, help='Path to dnlib.dll (required if you do not hardcode it into the script).')
args = parser.parse_args()

# define the path to dnlib.dll in case it is not provided as a parameter
if args.dnlib is not None:
    dnlib_path = args.dnlib_path
else:
    dnlib_path = r"C:\Users\flare\Desktop\Tools\custom\dnlib-master\Examples\bin\Debug\net45\dnlib.dll"

# Import dotnetfile components
from dotnetfile import DotNetPE
# Create an instance of DotNetPE with the file path as a parameter
dotnet_file = DotNetPE(args.file)

# Import the Common Language Runtime and add a reference to dnlib.dll
import clr,sys
clr.AddReference(dnlib_path)

# Import dnlib components
import dnlib
from dnlib.DotNet import *
from dnlib.DotNet.Emit import OpCodes

# Load the file into an object usable by dnlib
module = dnlib.DotNet.ModuleDefMD.Load(args.file)

# Non dotnet-related imports
import json
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


# Define the list of suspicious keywords
sus_list = ["key", "block", "size", "ip", "port", "rfce2898", "rijndael", "crypto", "algorithm", "iv", "md5", "sha1", "cipher"]
# hit_list will store the keywords found in method names in the assembly
hit_list = []
# strategies will store the dictionaries that contain the results of the strategies
strategies = []
# results will store the dictionaries that contain the outliers of the results of the strategies
results = []

# populate hit_list with the keywords found in method names in the assembly
def identify_strings_strings_hits():
    strings_strings = dotnet_file.get_strings_stream_strings()
    for i in strings_strings:
        for j in sus_list:
            if j.lower() in i.lower():
                hit_list.append(i)

# sort the methods and types in the module by the number of suspicious method names
def sort_by_method_names(sus_method_names, module):
    type_by_sus_methods = {"Strategy":"Types By Number Of Suspicious Methods", "strategies":{}}
    method_by_sus_methods = {"Strategy":"Methods By Number Of Suspicious Methods", "strategies":{}}
    for type in module.GetTypes():
        if not type.HasMethods:
            continue
        for method in type.Methods:
            if not method.HasBody: 
                continue
            if not method.Body.HasInstructions: 
                continue
            for term in sus_method_names:
                for ptr in range(len(method.Body.Instructions)):
                    try:
                        if term in method.Body.Instructions[ptr].ToString():
                            type_by_sus_methods['strategies'][type.ToString()] = type_by_sus_methods['strategies'].get(type.ToString(), 0) + 1
                            method_by_sus_methods['strategies'][method.ToString().split(" ")[1].split("(")[0]] = method_by_sus_methods['strategies'].get(method.ToString().split(" ")[1].split("(")[0], 0) + 1
                    except:
                        pass
    type_by_sus_methods['strategies'] = dict(sorted(type_by_sus_methods['strategies'].items(), reverse=True, key=lambda item: item[1]))
    method_by_sus_methods['strategies'] = dict(sorted(method_by_sus_methods['strategies'].items(), reverse=True, key=lambda item: item[1]))
    strategies.append(type_by_sus_methods)
    strategies.append(method_by_sus_methods)

# sort methods in the module by the percentage of ldstr and ldtoken instructions
def sort_by_instructions(module):
    method_by_ldtoken = {"Strategy":"Methods By Percentage Of ldtoken Instructions", "strategies":{}}
    method_by_ldstr = {"Strategy":"Methods By Percentage Of ldstr Instructions", "strategies":{}}
    for type in module.GetTypes():
        if not type.HasMethods:
            continue
        for method in type.Methods:
            if not method.HasBody: 
                continue
            if not method.Body.HasInstructions: 
                continue
            for ptr in range(len(method.Body.Instructions)):
                if method.Body.Instructions[ptr].OpCode == OpCodes.Ldtoken:
                    method_by_ldtoken['strategies'][method.ToString().split(" ")[1].split("(")[0]] = method_by_ldtoken['strategies'].get(method.ToString().split(" ")[1].split("(")[0], 0) + 1/len(method.Body.Instructions)
                if method.Body.Instructions[ptr].OpCode == OpCodes.Ldstr:
                    method_by_ldstr['strategies'][method.ToString().split(" ")[1].split("(")[0]] = method_by_ldstr['strategies'].get(method.ToString().split(" ")[1].split("(")[0], 0) + 1/len(method.Body.Instructions)
    method_by_ldtoken['strategies'] = dict(sorted(method_by_ldtoken['strategies'].items(), reverse=True, key=lambda item: item[1]))
    method_by_ldstr['strategies'] = dict(sorted(method_by_ldstr['strategies'].items(), reverse=True, key=lambda item: item[1]))
    strategies.append(method_by_ldtoken)
    strategies.append(method_by_ldstr)

# get high-value outliers for the results of each of the strategies
def get_outliers(strategies):
    for i in strategies:
        keys = np.array(list(i['strategies'].keys()))
        df = pd.DataFrame(np.array(list(i['strategies'].values())))
        q1=df.quantile(0.25)
        q3=df.quantile(0.75)
        IQR=q3-q1
        outliers = df[(df>(q3+1.5*IQR))]
        outlier_percentage = 1 - (df.shape[0] - outliers.notnull().sum(axis=0)) / df.shape[0]
        outliers.dropna(inplace=True)
        result_dict = {"Strategy":i['Strategy'], "Outlier Percentage":outlier_percentage.iloc[0], "Config Method Candidates": keys[:outliers.shape[0]].tolist()}
        results.append(result_dict)

# print the results based on outlier details
def print_results(result):
    print(f"\t-----{result['Strategy']}-----\n")
    for i in result['Config Method Candidates']:
        print(f"\t{i}")
    print("")

# order the strategies based on the proportion of outliers
def strategy_comparison(results):
    print("\n-------------------------------------------------------------")
    print("The following strategies for finding the config location are\nordered by likelihood of success given the assembly provided.")
    print("-------------------------------------------------------------\n")
    for i in sorted(results, reverse=True, key = lambda x: x['Outlier Percentage']):
        print_results(i)

# create bar charts of the results of all the strategies
def create_charts(strategies):
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, layout="constrained", figsize=(9,9))
    axes = [ax1, ax2, ax3, ax4]
    for i, a in zip(strategies, axes):
        truncated_labels = [elem[:25] for elem in list(i['strategies'].keys())[:10]]
        x = np.array(truncated_labels)
        y = np.array(list(i['strategies'].values())[:10])
        a.bar(x, y)
        a.set_title(i['Strategy'])
        a.tick_params(axis='x', labelrotation=90)
    plt.show()

def main():
    identify_strings_strings_hits()
    sort_by_method_names(hit_list, module)
    sort_by_instructions(module)
    get_outliers(strategies)
    strategy_comparison(results)
    create_charts(strategies)

if __name__ == "__main__":
    main()