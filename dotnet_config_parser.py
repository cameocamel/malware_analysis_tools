#!/usr/bin/env python3

# Most of this script/module is taken from here: https://github.com/jeFF0Falltrades/Tutorials/blob/master/asyncrat_config_parser/asyncrat_config_parser.py
# The main changes are as follows.
# 
#      1.The decrypt_config(self) function was changed to perform a different decryption 
# routine.
#      2.The ASyncRATAESDecryptor class was removed.
#      3.The get_config_address_map(self) and strings_rva_to_strings_val(self, strings_rva) functions 
# were edited to add a check for whether the ldtoken or call instruction is used in the config 
# code. If call is used, then instead of looking in the Field table for the config entry name 
# value, the script looks in the Method table. The original script only considers where ldtoken 
# is used.
# 
# Edit the decrypt_config(self) function to change the decryption function. This function lops 
# through the encrypted config values contained in the dictionary, self.translated_config, and 
# upon decryption adds them to the dictionary, decrypted_config.
# 
# If a dotnet malware is used basic hardcoded strings for its config, you may be able to use this 
# script to extract the config by just editing the signature values (PATTERN_CONFIG_START, 
# PATTERN_PARSED_RVAS and PATTERN_CONFIG_NAME_INSTRUCTION) and the decryption function.

from argparse import ArgumentParser
from base64 import b64decode, b64encode
from itertools import cycle
from json import dumps
from logging import basicConfig, DEBUG, exception, getLogger, WARNING
from re import DOTALL, findall, search

logger = getLogger(__name__)


# An importable parser class which encompasses all operations for parsing and
# decrypting (unobfuscated) dotnet payload configurations
class dotnetParser:

    OPCODE_RET = b'\x2a'
    PATTERN_CLR_METADATA_START = b'\x42\x53\x4a\x42'
    PATTERN_CONFIG_START = b'(\x72.{9}){3}'
    PATTERN_PARSED_RVAS = b'\x72(.{4}).(.{4})'
    PATTERN_CONFIG_NAME_INSTRUCTION = b'\x72.{4}(.)'
    RVA_FIELD_TABLE_BASE = 0x04000000
    RVA_METHOD_TABLE_BASE = 0x06000000
    RVA_US_BASE = 0x70000000
    STREAM_IDENTIFIER_STORAGE = b'#~'
    STREAM_IDENTIFIER_STRINGS = b'#Strings'
    STREAM_IDENTIFIER_US = b'#US'
    TABLE_FIELD = 'Field'
    config_name_instruction=b""

    # This map assists in calculating offsets for Field and FieldRVA entries.
    #
    # These calculations require knowing:
    #     1. The size of a row in the specified table (hardcoded here)
    #     2. The number of rows in the table (calculated in get_table_map())
    #
    # We have only hardcoded in row sizes through the FieldRVA table because
    # this is the last table we need for our parser to function.
    #
    # We still include the remaining tables because we will need to check if
    # these are present to calculate the offset to a table in get_table_start().
    #
    # If you are interested in generalizing this map to examine other tables,
    # I recommend checking out dnSpy's algorithm for calculating table row size
    # for the remaining tables here:
    #
    # https://github.com/dnSpy/dnSpy/blob/2b6dcfaf602fb8ca6462b8b6237fdfc0c74ad994/dnSpy/dnSpy/Hex/Files/DotNet/DotNetTableSizes.cs
    MAP_TABLE = {
        'Module': {
            'row_size': 10
        },
        'TypeRef': {
            'row_size': 6
        },
        'TypeDef': {
            'row_size': 14
        },
        'FieldPtr': {
            'row_size': 2
        },
        'Field': {
            'row_size': 6
        },
        'MethodPtr': {
            'row_size': 2
        },
        'Method': {
            'row_size': 14
        },
        'ParamPtr': {
            'row_size': 2
        },
        'Param': {
            'row_size': 6
        },
        'InterfaceImpl': {
            'row_size': 4
        },
        'MemberRef': {
            'row_size': 6
        },
        'Constant': {
            'row_size': 6
        },
        'CustomAttribute': {
            'row_size': 6
        },
        'FieldMarshal': {
            'row_size': 4
        },
        'DeclSecurity': {
            'row_size': 6
        },
        'ClassLayout': {
            'row_size': 8
        },
        'FieldLayout': {
            'row_size': 6
        },
        'StandAloneSig': {
            'row_size': 2
        },
        'EventMap': {
            'row_size': 4
        },
        'EventPtr': {
            'row_size': 2
        },
        'Event': {
            'row_size': 6
        },
        'PropertyMap': {
            'row_size': 4
        },
        'PropertyPtr': {
            'row_size': 2
        },
        'Property': {
            'row_size': 6
        },
        'MethodSemantics': {
            'row_size': 6
        },
        'MethodImpl': {
            'row_size': 6
        },
        'ModuleRef': {
            'row_size': 2
        },
        'TypeSpec': {
            'row_size': 2
        },
        'ImplMap': {
            'row_size': 8
        },
        'FieldRVA': {
            'row_size': 6
        },
        'ENCLog': {},
        'ENCMap': {},
        'Assembly': {},
        'AssemblyProcessor': {},
        'AssemblyOS': {},
        'AssemblyRef': {},
        'AssemblyRefProcessor': {},
        'AssemblyRefOS': {},
        'File': {},
        'ExportedType': {},
        'ManifestResource': {},
        'NestedClass': {},
        'GenericParam': {},
        'MethodSpec': {},
        'GenericParamConstraint': {},
        'Reserved 2D': {},
        'Reserved 2E': {},
        'Reserved 2F': {},
        'Document': {},
        'MethodDebugInformation': {},
        'LocalScope': {},
        'LocalVariable': {},
        'LocalConstant': {},
        'ImportScope': {},
        'StateMachineMethod': {},
        'CustomDebugInformation': {},
        'Reserved 38': {},
        'Reserved 39': {},
        'Reserved 3A': {},
        'Reserved 3B': {},
        'Reserved 3C': {},
        'Reserved 3D': {},
        'Reserved 3E': {},
        'Reserved 3F': {}
    }


    # Custom exception class to provide detailed exceptions from the parser
    class dotnetParserError(Exception):
        pass

    def __init__(self, file_path):
        self.file_path = file_path
        self.data = self.get_file_data()
        self.table_map = self.get_table_map()
        self.fields_map = self.get_fields_map()
        self.config_addr_map = self.get_config_address_map()
        self.translated_config = self.get_translated_config()
        self.config = self.decrypt_config()

    # Converts a bytes object to an int object using the specified byte order
    # (little-endian by default)
    def bytes_to_int(self, bytes, order='little'):
        try:
            result = int.from_bytes(bytes, byteorder=order)
        except Exception as e:
            raise self.dotnetParserError(
                f'Error parsing int from value: {bytes}') from e
        return result

    # Decodes a bytes object to a Unicode string, using UTF-16LE for byte values
    # with null bytes still embedded in them, and UTF-8 for all other values
    def decode_bytes(self, byte_str):
        result = None
        try:
            if b'\x00' in byte_str:
                result = byte_str.decode('utf-16le')
            else:
                result = byte_str.decode('utf-8')
        except Exception as e:
            raise self.dotnetParserError(
                f'Error decoding bytes object to Unicode: {byte_str}') from e
        return result

    # Given a translated config containing config field names and encrypted
    # and/or base64-encoded field values, decodes and decrypts encrypted values
    # and returns the decrypted config
    def decrypt_config(self):
        logger.debug('Decrypting config...')
        decrypted_config = {}
        xor_key = ""
        for k, v in self.translated_config.items():
            k = self.decode_bytes(k)
            v = self.decode_bytes(v)
            if v != "":
                try:
                    b64encode(b64decode(v))
                except Exception:
                    xor_key = v
                    decrypted_config['xorkey'] = v
                    break
            else:
                decrypted_config[k] = v
        for k, v in self.translated_config.items():
            k = self.decode_bytes(k)
            v = self.decode_bytes(v)
            if v != "":
                try:
                    b64_decoded = b64decode(v)
                    decrypted = bytes(a ^ b for a, b in zip(b64_decoded, cycle(bytes(xor_key, 'utf-8'))))
                    b64_decoded_again = b64decode(decrypted).decode('utf-8')
                    decrypted_config[k] = b64_decoded_again
                    logger.debug(f'Key: {k}, Value: {decrypted_config[b64_decoded_again]}')
                except Exception:
                    pass
        logger.debug('Successfully decrypted config')
        return decrypted_config

    # Searches for the configuration section,
    # and attempts to extract the RVAs of the config field names and values
    #
    def get_config_address_map(self):
        logger.debug('Extracting the config address map...')
        config_mappings = []
        hit = search(self.PATTERN_CONFIG_START, self.data, DOTALL)
        if hit is None:
            raise self.dotnetParserError('Could not find start of config')
        config_start = hit.start()
        # Configuration ends with ret operation, so we get string using the ret
        # opcode (0x2A) as our terminating char
        parsed_ops = self.get_string_from_offset(config_start, self.OPCODE_RET)
        # Split the field name RVAs from the field value RVAs in our parsed ops
        parsed_rvas = findall(self.PATTERN_PARSED_RVAS, parsed_ops, DOTALL)
        self.config_name_instruction = search(self.PATTERN_CONFIG_NAME_INSTRUCTION, parsed_ops, DOTALL).groups()[0]
        for (us_rva, string_rva) in parsed_rvas:
            config_value_rva = self.bytes_to_int(us_rva)
            config_name_rva = self.bytes_to_int(string_rva)
            logger.debug(
                f'Found config item: ({hex(config_value_rva)}, {hex(config_name_rva)})'
            )
            config_mappings.append((config_value_rva, config_name_rva))
        logger.debug('Successfully extracted config address map')
        return config_mappings

    # Extracts the Field table of the assembly, mapping the value of each
    # field from the #Strings stream to its offset in the Field table
    def get_fields_map(self):
        logger.debug('Extracting fields map...')
        fields_map = []
        fields_start = self.get_table_start(self.TABLE_FIELD)
        strings_start = self.get_stream_start(self.STREAM_IDENTIFIER_STRINGS)
        # Start at the beginning of the Field table
        cur_offset = fields_start
        for x in range(self.table_map[self.TABLE_FIELD]['num_rows']):
            try:
                field_offset = self.bytes_to_int(self.data[cur_offset +
                                                           2:cur_offset + 4])
                field_value = self.get_string_from_offset(strings_start +
                                                          field_offset)
                # Proceed to next row
                cur_offset += self.table_map[self.TABLE_FIELD]['row_size']
            except Exception as e:
                raise self.dotnetParserError(
                    'Error parsing Field table') from e
            logger.debug(f'Found field: {hex(field_offset)}, {field_value}')
            fields_map.append((field_value, field_offset))
        logger.debug('Successfully extracted fields map')
        return fields_map

    # Given a file path, reads in and returns binary contents from that path
    def get_file_data(self):
        logger.debug(f'Reading contents from: {self.file_path}')
        try:
            with open(self.file_path, 'rb') as fp:
                data = fp.read()
        except Exception as e:
            raise self.dotnetParserError(
                f'Error reading from path: {self.file_path}') from e
        logger.debug('Successfully read data')
        return data

    # Extracts the m_maskvalid value from the Tables Stream
    def get_mask_valid(self):
        logger.debug('Extracting m_maskvalid value...')
        storage_stream_offset = self.get_stream_start(
            self.STREAM_IDENTIFIER_STORAGE)
        mask_valid_offset = storage_stream_offset + 8
        mask_valid = self.bytes_to_int(
            self.data[mask_valid_offset:mask_valid_offset + 8])
        logger.debug(f'Extracted m_maskvalid: {hex(mask_valid)}')
        return mask_valid

    # Finds the start of the Common Language Runtime (CLR) metadata header
    # using the metadata start flag (0x424a5342)
    def get_metadata_header_offset(self):
        hit = self.data.find(self.PATTERN_CLR_METADATA_START)
        if hit == -1:
            raise self.dotnetParserError(
                'Could not find start of CLR metadata header')
        return hit

    # Given a stream identifier (e.g. #Strings or #US), finds the file offset
    # of the start of the stream
    def get_stream_start(self, stream_identifier):
        metadata_header_offset = self.get_metadata_header_offset()
        hit = self.data.find(stream_identifier)
        if hit == -1:
            raise self.dotnetParserError(
                f'Could not find offset of stream {stream_identifier}')
        stream_offset = self.bytes_to_int(self.data[hit - 8:hit - 4])
        return metadata_header_offset + stream_offset

    # Given a string offset and, optionally, a delimiter (default terminating
    # null byte), extracts a string from the offset
    def get_string_from_offset(self, str_offset, delimiter=b'\0'):
        try:
            result = self.data[str_offset:].partition(delimiter)[0]
        except Exception as e:
            raise self.dotnetParserError(
                f'Could not extract string value from offset {hex(str_offset)} with delimiter {delimiter}'
            ) from e
        return result

    # Creates a copy of the table map template above and populates it with
    # extracted table data from the payload, including tables present and
    # number of rows per table
    def get_table_map(self):
        logger.debug('Extracting table map...')
        mask_valid = self.get_mask_valid()
        # Ensure we use copy() here because, if not, every newly instantiated
        # dotnetParser object will have the same table map, and changes to
        # one will impact all others
        table_map = self.MAP_TABLE.copy()
        storage_stream_offset = self.get_stream_start(
            self.STREAM_IDENTIFIER_STORAGE)
        # Table row counts start 24 bytes after storage stream start
        table_start = storage_stream_offset + 24
        cur_offset = table_start
        try:
            for table in table_map:
                # m_maskvalid tells us which tables are present in this
                # particular assembly, with each table receiving one bit in the
                # mask. If this bit is set to 1, the table is present.
                #
                # So to check for table presence, we use the bitwise formula:
                #
                # Table Present = m_maskvalid AND (2^table index)
                if mask_valid & (2**list(table_map.keys()).index(table)):
                    row_count_packed = self.data[cur_offset:cur_offset + 4]
                    row_count = self.bytes_to_int(row_count_packed)
                    table_map[table]['num_rows'] = row_count
                    logger.debug(f'Found {row_count} rows for table {table}')
                    cur_offset += 4
                else:
                    table_map[table]['num_rows'] = 0
        except Exception as e:
            raise self.dotnetParserError(
                'Could not get counts of rows from tables') from e
        logger.debug('Successfully extracted table map')
        return table_map

    # Given the name of a table in the Tables Stream, finds the offset pointing
    # to the start of that table
    def get_table_start(self, table_name):
        storage_stream_offset = self.get_stream_start(
            self.STREAM_IDENTIFIER_STORAGE)
        # Table Start = Table Stream Start + 4 bytes for the row size of each
        #               table present in the assembly
        #             = (24 + Storage stream start) + (4 * each table present
        #               in the assembly)
        tables_start_offset = storage_stream_offset + 24 + (4 * len([
            table for table in self.table_map
            if self.table_map[table]['num_rows'] > 0
        ]))

        table_offset = tables_start_offset
        for table in self.table_map:
            # Break if we have found our table
            if table == table_name:
                break
            # If we no longer find 'row_size', we are past the point we should
            # be, at least for our parser, as that means we've passed the
            # FieldRVA table
            elif 'row_size' not in self.table_map[table]:
                raise self.dotnetParserError('Invalid table offset found')
            # Increment by (row size * number of rows in current table) bytes
            table_offset += self.table_map[table]['row_size'] * self.table_map[
                table]['num_rows']
        return table_offset

    # Translates encrypted config addresses to their values from their RVAs
    def get_translated_config(self):
        logger.debug('Translating configuration addresses to values...')
        translated_config = {}
        for (us_rva, strings_rva) in self.config_addr_map:
            try:
                field_name = self.strings_rva_to_strings_val(strings_rva)
                field_value = self.us_rva_to_us_val(us_rva)
                logger.debug(
                    f'Found config value: {field_name} = {field_value}')
                translated_config[field_name] = field_value
            except Exception as e:
                raise self.dotnetParserError(
                    f'Error translating RVAs {hex(us_rva)} and {hex(strings_rva)}'
                ) from e
        logger.debug('Successfully translated configuration')
        return translated_config

    # Returns metadata and the decrypted configuration for a payload
    def report(self):
        result_dict = {
            'file_path': self.file_path,
            'config': self.config
        }
        return result_dict

    # Given an RVA from the #Strings stream, extracts the value of the string
    # at that RVA using our extracted Fields map
    def strings_rva_to_strings_val(self, strings_rva):
        rva_strings_stream_base = 0x0
        if self.config_name_instruction == b"\x80":
            rva_strings_stream_base = self.RVA_FIELD_TABLE_BASE
        elif self.config_name_instruction == b"\x28":
            rva_strings_stream_base = self.RVA_METHOD_TABLE_BASE

        # Index of value in fields_map = RVA - #Strings base RVA - 1, e.g.:
        #
        # RVA: 0x04000001
        # Index = 0x04000001 - 0x04000000 - 1 = 0
        val_index = strings_rva - rva_strings_stream_base - 1
        try:
            strings_val = self.fields_map[val_index][0]
        except Exception as e:
            raise self.dotnetParserError(
                f'Could not retrieve string from RVA {strings_rva}') from e
        return strings_val

    # Given an RVA from the #US stream, extracts the value of the string
    # at that RVA
    def us_rva_to_us_val(self, us_rva):
        us_start = self.get_stream_start(self.STREAM_IDENTIFIER_US)
        # Strings in the #US stream are prefaced with 1-2 length bytes
        #
        # If the length of the string is >= 128 bytes, 2 bytes will be used
        # to indicate length, and the first byte's most significant bit will be
        # set.
        #
        # So we first check if the first length byte & 0x80 (1000 0000) is 1.
        #
        # If so, then this indicates we are dealing with a long string, and we
        # grab the size from 2 length bytes instead of 1.
        #
        # If not, then we can assume there is only 1 length byte to read from
        # and then skip over it to get to the string
        length_byte_offset = us_rva - self.RVA_US_BASE + us_start
        if int(self.data[length_byte_offset]) & 0x80:
            val_offset = 2
            # Notice we use big-endianness here, and also that we subtract the
            # most significant bit of the two length bytes (0x8000 or 1000 0000
            # 0000 0000) serving as a flag
            val_size = self.bytes_to_int(
                self.data[length_byte_offset:length_byte_offset + 2],
                'big') - 0x8000
        else:
            val_offset = 1
            val_size = self.data[length_byte_offset]
        val_offset += length_byte_offset
        # Subtract 1 to account for null terminator at the end of the string
        us_val = self.data[val_offset:val_offset + val_size - 1]
        return us_val


if __name__ == '__main__':
    ap = ArgumentParser()
    ap.add_argument(
        'file_paths',
        nargs='+',
        help='One or more dotnet payload file paths (deobfuscated)')
    ap.add_argument('-d',
                    '--debug',
                    action='store_true',
                    help='Enable debug logging')
    args = ap.parse_args()
    if args.debug:
        basicConfig(level=DEBUG)
    else:
        basicConfig(level=WARNING)

    decrypted_configs = []
    for fp in args.file_paths:
        try:
            decrypted_configs.append(dotnetParser(fp).report())
        except:
            logger.exception(f'Exception occurred for {fp}', exc_info=True)
            continue

    if len(decrypted_configs) > 0:
        print(dumps(decrypted_configs))