# This script must be run from the same directory as the batch file

from argparse import ArgumentParser
import re
import os
import sys
import ntpath

# for transformations of the form %<var>:<to_replace>=<replacement>%
REGEX_REPLACE = "%([^%]+?):(.+?)%"
# for simple substitutions of the form: %<var>%
REGEX_DIRECT_REPLACE = "%([^%:()='\"~ ]+?)%"
# for transformations of the form %<var>:~<index>,<num_of_chars>%
REGEX_UNICODE_INDEX = b"%([^%]+?):~([0-9]+),([0-9]+)%"
REGEX_UNICODE_DIRECT_REPLACE = b"%([^%:()='\"~ ]+?)%"


parser = ArgumentParser('Batch (.bat) File Deobfuscator', 'Deobfuscates a batch file, outputting the result to a file, and outputting an additional file which pretty prints any identified PowerShell commands.')
parser.add_argument('-f', '--filepath', type=os.path.abspath, required=True, help='Batch (.bat) file to deobfuscate')
args = parser.parse_args()
filepath = args.filepath

filetowrite = filepath.split('.')[0] + '_deobfuscated.' + filepath.split('.')[-1]

# a dictoinary to store the environment variables the batch file sets
vars = {"temp":"C:\Temp","Temp":"C:\Temp"}


file_is_binary = False

try:
     with open(filepath, 'r') as fileread:
          lines = fileread.readlines()
          fileread.close()
except UnicodeDecodeError:
     file_is_binary = True
     with open(filepath, 'rb') as fileread:
          lines = fileread.readlines()
          fileread.close()



if not file_is_binary:
     with open(filetowrite, 'w') as filewrite:
          for y in range(len(lines)):
               # easier to deal with everything in one case, and strip any trailing new lines
               # which Python's readline() sometimes adds
               lines[y] = lines[y].lower().rstrip('\n')
               # skip any comment lines, as these can be lengthy if they include payloads,
               # which makes reading the deobfuscated file more difficult
               if lines[y].startswith("::") or lines[y].startswith("REM"):
                    continue
               # for any lines with comments not at the beginning, delete the comments
               if "::" in lines[y]:
                    lines[y] = lines[y][:lines[y].index("::")]
               # expand out the shortcuts that can be used to refer to the current file/filpath/its directory
               if "%~dp0" in lines[y]:
                    lines[y] = lines[y].replace("%~dp0", f"{filepath[:filepath.index(ntpath.basename(filepath))]}")
               if "%~nx0" in lines[y]:
                    lines[y] = lines[y].replace("%~nx0", f"{ntpath.basename(filepath)}")
               if "%~0" in lines[y]:
                    lines[y] = lines[y].replace("%~0", f"{ntpath.basename(filepath)}")
               # storing any set environment variables in the vars dictionary
               if 'set" "' in lines[y]:
                    lines[y] = lines[y].replace('set" "', 'set "')
               if 'set ""' in lines[y]:
                    lines[y] = lines[y].replace('set ""', 'set "')
               # perform  transformations of the form %<var>:<to_replace>=<replacement>%
               if re.search(REGEX_REPLACE, lines[y]):
                    matches = re.findall(REGEX_REPLACE, lines[y])
                    for i in matches:
                         if "=" in i[1]:
                              var = i[0]
                              to_replace = i[1].split("=")[0]
                              # the replacement could be an equal sign, so we can't simply
                              # use the second memory of .split("=")
                              replacement = i[1].split("=")[1]
                              #replacement = i[1][i[1].index("="):]
                              try:
                                   lines[y] = lines[y].replace(to_replace + "=" + replacement + "%", to_replace + "=" + replacement)
                                   lines[y] = lines[y].replace(to_replace + "=", to_replace).replace("%" + var  + ":", vars[var]).replace(to_replace, replacement)
                              except KeyError:
                                   continue
               # perform  transformations of the form %<var>%
               if re.search(REGEX_DIRECT_REPLACE, lines[y]):
                    matches = re.findall(REGEX_DIRECT_REPLACE, lines[y])
                    for i in matches:
                         try:
                              lines[y] = lines[y].replace("%" + i + "%", vars[i])
                         except KeyError:
                              lines[y] = lines[y].replace("%" + i + "%", "")
                              continue
               # we don't really care if the @ symbol is used before set as all it does is
               # make the output less verbose, so it's easier just to remove it
               # https://stackoverflow.com/questions/21074863/what-is-the-at-sign-in-a-batch-file-and-what-does-it-do
               if '@set ' in lines[y]:
                    lines[y] = lines[y].replace('@set ', 'set ')
               if lines[y].startswith("set "):
                    if lines[y].startswith("set \"") or lines[y].startswith("set '"):
                         k = lines[y].split("=")[0][len("set \""):]
                         v = lines[y][len(k) + len("set =\""):lines[y].rfind("\"")]
                    else:
                         k = lines[y].split("=")[0][len("set "):]
                         v = lines[y][len(k) + len("set ="):]
                         print(v)
                         print("test")
                    vars[k] = v
                    continue
               #7z self-extracting archives are essentially a version of a batch script, but instead of using
               # the "set" command to set environment variables, it uses setenvironment
               if lines[y].startswith("setenvironment="):
                    k = lines[y].split("=")[1][len("\""):]
                    v = lines[y][len(k) + len("setenvironment=\"") + len("="):lines[y].rfind("\"")]
                    vars[k] = v
                    continue
               # print a new line so the results are more easily readable
               if not lines[y].isspace():
                    filewrite.write(lines[y])
                    filewrite.write("\n")
               print(vars)
          filewrite.close()



if file_is_binary:
     with open(filetowrite, 'wb') as filewrite:
          for y in range(len(lines)):
               if re.search(REGEX_UNICODE_DIRECT_REPLACE, lines[y]):
                    matches = re.findall(REGEX_UNICODE_DIRECT_REPLACE, lines[y])
                    for i in matches:
                         try:
                              lines[y] = lines[y].replace(b"%" + i + b"%", vars[i])
                         except KeyError:
                              lines[y] = lines[y].replace(b"%" + i + b"%", b"")
                              continue
               #the belwo is not needed anymore as I realised we can just delte any variables not matched as part of the direct replacement transformation
               # for any false variables, i.e. gibberish enclosed in percent signs
               # REGEX_UNICODE_GIBBERISH = b"(%[^%=\":0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]+%)"
               # remove gibberish
               #if re.search(REGEX_UNICODE_GIBBERISH, lines[y]):
               #     matches = re.findall(REGEX_UNICODE_GIBBERISH, lines[y])
               #     for i in matches:
               #          lines[y] = lines[y].replace(i, b"")
               # perform  transformations of the form %<var>:~<index>,<num_of_chars>%
               if re.search(REGEX_UNICODE_INDEX, lines[y]):
                    matches = re.findall(REGEX_UNICODE_INDEX, lines[y])
                    for i in matches:
                         var = i[0]
                         ind = i[1]
                         num = i[2]
                         ind_b = int(ind.decode("utf-8"))
                         num_b = int(num.decode("utf-8"))
                         try:
                              lines[y] = lines[y].replace(b"%" + var + b":~" + ind + b"," + num + b"%", vars[var][ind_b:ind_b+num_b])
                         except KeyError:
                              continue
               if b"set " in lines[y]:
                    if b"set \"" not in lines[y]:
                         k = lines[y].split(b"=")[0][lines[y].index(b"set ") + len(b"set "):]
                         v = "Test"
                    if b"set \"" in lines[y]:
                         k = lines[y].split(b"=")[0][lines[y].index(b"set \"") + len(b"set \""):]
                         v = lines[y].split(b"=")[1].split(b"\"")[0]
                    vars[k] = v
               filewrite.write(lines[y])          
          filewrite.close()






filepath = filetowrite
filetowrite = filepath.split('.')[0] + '_multiline.' + filepath.split('.')[-1]

squiggly_count = 0

with open(filepath, 'r') as fileread:
     with open(filetowrite, 'w') as filewrite:
          for line in fileread:
               for i, c in enumerate(line):
                    # for each opening squiqqly bracket, print it, then increment the bracket count
                    # and print a new line and the correct number of tabs
                    if c == '{':
                         filewrite.write(c)
                         squiggly_count += 1
                         filewrite.write('\n' + squiggly_count * '\t')
                         continue
                    # for each closing squiqqly bracket, decrement the bracket count,
                    # print a new line and the correct number of tabs, then the bracket, than a new line
                    elif c == '}':
                         squiggly_count -= 1
                         filewrite.write("\n" + squiggly_count * '\t' + c + "\n")
                         if squiggly_count == 0:
                              filewrite.write("\n")
                         continue
                    # for each semicolon, print it followed by a new line and the correct number of tabs
                    elif c == ';':
                         filewrite.write(c)
                         if line[i + 1] != '}':
                              filewrite.write('\n' + squiggly_count * '\t')
                         if squiggly_count == 0:
                              filewrite.write("\n")
                         continue
                    # for each space, if it follows a semicolon, do not print it. This is because it will
                    # mess up the indentation
                    elif c == ' ':
                         if line[i - 1] == ';':
                              continue
                    filewrite.write(c)
                    continue
          filewrite.close()
          fileread.close()