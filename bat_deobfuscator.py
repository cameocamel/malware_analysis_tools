#! /usr/bin/env python


'''
Obfuscated batch files may be in ascii or another encoding. The easiest way I have found to deal
with multiple possible encodings, is to read the file and determine if it is ascii, and if it is,
to convert the entire read contents to bytes. All the Python code can then work in bytes. When
writing the deobfuscated file, one can convert the contents back into ascii, as all non-ascii
characters should have been removed as part of the deobfuscation process.
'''

from argparse import ArgumentParser
import re
import os
import sys
import ntpath
import logging, sys

logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

# for transformations of the form %<var>:<to_replace>=<replacement>%
REGEX_REPLACE_SUBSTRING = b"%([^%]+?):(.+?)%"
# for simple substitutions of the form: %<var>%
REGEX_DIRECT_REPLACE = b"%([^%]+?)%"
# for transformations of the form %<var>:~<index>,<num_of_chars>%
REGEX_INDEX = b"%([^%]+?):~([0-9]+),([0-9]+)%"
# for transformations of the form !<var>!
REGEX_EXCLAMATION = b"!([^!]+?)!"

# a dictionary to store the environment variables the batch file sets
vars = {"temp":"C:\Temp","Temp":"C:\Temp"}

def parse_args():
     parser = ArgumentParser('Batch (.bat) File Deobfuscator', 'Deobfuscates a batch file, outputting the result to a file, and outputting an additional file which pretty prints any identified PowerShell commands.')
     parser.add_argument('-f', '--filepath', type=os.path.abspath, required=True, help='Batch (.bat) file to deobfuscate')
     args = parser.parse_args()
     filepath = args.filepath
     filetowrite = filepath.split('.')[0] + '_deobfuscated.' + filepath.split('.')[-1]
     filetowrite_comment = filepath.split('.')[0] + '_comments.' + filepath.split('.')[-1]
     return filepath, filetowrite, filetowrite_comment


def open_file(filepath):
     logging.debug(f"Attempting to read the input file: {filepath}")
     global file_is_binary
     file_is_binary = False
     try:
          with open(filepath, 'r') as fileread:
               global lines
               lines = fileread.readlines()
               fileread.close()
     except UnicodeDecodeError:
          file_is_binary = True
          print(b"Binary File Identified")
          with open(filepath, 'rb') as fileread:
               lines = fileread.readlines()
               fileread.close()
     if fileread:
          logging.debug("Input file read.")


def initial_cleanup(line):
     # if a line is a comment we want to print it to a separate file, as payloads
     # can be found in comments and can be very large, obscuring the deobfusacted commands
     comment_line = False
     # easier to deal with everything in one case, and strip any trailing new lines
     # which Python's readline() sometimes adds
     line = line.lower().rstrip(b"\n")
     # skip any comment lines, as these can be lengthy if they include payloads,
     # which makes reading the deobfuscated file more difficult
     if line.startswith(b"::") or line.startswith(b"rem"):
          comment_line = True
          logging.debug("Line starts with :: or rem, i.e., is a comment line.")
          return line, comment_line
     # expand out the shortcuts that can be used to refer to the current file/filpath/its directory
     if b"%~dp0" in line:
          line = line.replace(b"%~dp0", filepath[:filepath.index(ntpath.basename(filepath))].encode('ASCII'))
          logging.debug("Made a %~dp0 substitution")
     if b"%~nx0" in line:
          line = line.replace(b"%~nx0", ntpath.basename(filepath).encode('ASCII'))
          logging.debug("Made a %~nx0 substitution")
     if b"%~0" in line:
          line = line.replace(b"%~0", ntpath.basename(filepath).encode('ASCII'))
          logging.debug("Made a %~0 substitution")
     return line, comment_line

def set_env_variables(line):
     # we don't want to write the line if it is just setting env variables
     # for the purposes of deobfuscation, so we use a flag to indicate whether
     # we want to write a line or not.
     write_line = True
     # storing any set environment variables in the vars dictionary
     k=""
     v=""
     if b"set\" \"" in line:
          line = line.replace(b"set\" \"", b"set \"")
     if b"set \"\"" in line:
          line = line.replace(b"set \"\"", b"set \"")
     # we don't really care if the @ symbol is used before set as all it does is
     # make the output less verbose, so it's easier just to remove it
     # https://stackoverflow.com/questions/21074863/what-is-the-at-sign-in-a-batch-file-and-what-does-it-do
     if b"@set " in line:
          line = line.replace(b"@set ", b"set ")
     if line.startswith(b"set ") and b"=" in line:
          if line.startswith(b"set \"") or line.startswith(b"set '"):
               k = line.split(b"=")[0][len(b"set \""):]
               v = line[len(k) + len(b"set =\""):line.rindex(b"\"")]
          else:
               k = line.split(b"=")[0][len(b"set "):]
               v = line[len(k) + len(b"set ="):]
          vars[k] = v
          logging.debug(f'Set environment variables: "{k.decode("utf-8")}":"{v.decode("utf-8")}"')
          write_line = False
          return line, write_line
     if b"set " in line:
          if b"set \"" not in line:
               k = line.split(b"=")[0][line.index(b"set ") + len(b"set "):]
               v = b"Test"
          if b"set \"" in line and b"=" in line:
               print(line)
               k = line.split(b"=")[0][line.index(b"set \"") + len(b"set \""):]
               v = line.split(b"=")[1].split(b"\"")[0]
          vars[k] = v
          logging.debug(f'Set environment variables: "{k.decode("utf-8")}":"{v.decode("utf-8")}"')
          write_line = False
          write_line = False
          return line, write_line
     #7z self-extracting archives are essentially a version of a batch script, but instead of using
     # the b"set" command to set environment variables, it uses setenvironment
     if line.startswith(b"setenvironment="):
          k = line.split(b"=")[1][len(b"\""):]
          v = line[len(k) + len(b"setenvironment=\"") + len(b"="):line.rindex(b"\"")]
          vars[k] = v
          logging.debug(f'Set environment variable: "{k.decode("utf-8")}":"{v.decode("utf-8")}"')
          write_line = False
          return line, write_line
     return line, write_line

def replace_substring(line):
# perform  transformations of the form %<var>:<to_replace>=<replacement>%
     if re.search(REGEX_REPLACE_SUBSTRING, line):
          matches = re.findall(REGEX_REPLACE_SUBSTRING, line)
          for i in matches:
               if b"=" in i[1]:
                    var = i[0]
                    to_replace = i[1].split(b"=")[0]
                    # the replacement could be an equal sign, so we can't simply
                    # use the second memory of .split(b"=")
                    replacement = i[1].split(b"=")[1]
                    #replacement = i[1][i[1].index(b"="):]
                    try:
                         line = line.replace(to_replace + b"=" + replacement + b"%", to_replace + b"=" + replacement)
                         line = line.replace(to_replace + b"=", to_replace).replace(b"%" + var  + b":", vars[var]).replace(to_replace, replacement)
                         logging.debug("Performing a substring replacement.")
                    except KeyError:
                         continue
     return line

def replace_direct(line):
     # perform  transformations of the form %<var>%
     if re.search(REGEX_DIRECT_REPLACE, line):
          matches = re.findall(REGEX_DIRECT_REPLACE, line)
          for i in matches:
               try:
                    line = line.replace(b"%" + i + b"%", vars[i])
                    logging.debug(f"Performing a direct replacement. Replaced {i} with {vars[i]}")
               except KeyError:
                    line = line.replace(b"%" + i + b"%", b"")
                    continue
     # in some cases there are some substitutions that are not performed on a first run
     # so we perform the direct replacement substitution method once more, however,
     # we replace the nonsense substitutions with a space on the second run, as for some
     # reason spaces get lost otherwise
     if re.search(REGEX_DIRECT_REPLACE, line):
          matches = re.findall(REGEX_DIRECT_REPLACE, line)
          for i in matches:
               try:
                    line = line.replace(b"%" + i + b"%", vars[i])
                    logging.debug(f"Performing a direct replacement. Replaced {i} with {vars[i]}")
               except KeyError:
                    line = line.replace(b"%" + i + b"%", b" ")
                    continue
     return line

def replace_index(line):
     if re.search(REGEX_INDEX, line):
          #print(b"index")
          matches = re.findall(REGEX_INDEX, line)
          for i in matches:
               var = i[0]
               ind = i[1]
               num = i[2]
               ind_b = int(ind.decode("utf-8"))
               num_b = int(num.decode("utf-8"))
               try:
                    #print(vars[var][ind_b:ind_b+num_b])
                    line = line.replace(b"%" + var + b":~" + ind + b"," + num + b"%", vars[var][ind_b:ind_b+num_b])
                    logging.debug("Performing an index replacement.")
               except KeyError:
                    continue
     return line

def write_text(filewrite, line, comment_line, filewrite_comment, write_line ):
     if comment_line:
          try:
               filewrite_comment.write(line.decode("utf-8"))
               logging.debug("Wrote a comment line to the comment output file.")
               # print a new line so the results are more easily readable
               filewrite_comment.write("\n")
          except UnicodeDecodeError:
               return
          return
     if write_line and not line.isspace():
          # we don't want to write any unicode characters, as these should have all been deobfuscated anyway.
          # Any remaining unicode characters may be present as part of set commands (where the variable is in unicode),
          # but we don't want to print those anyway. 
          try:
               filewrite.write(line.decode("utf-8"))
               # print a new line so the results are more easily readable
               filewrite.write("\n")
               #logging.debug(f"Line written: {line}")
          except UnicodeDecodeError:
               return


def prettify(filetowrite):

     filepath = filetowrite
     filetowrite = filepath.split(".")[0] + "_prettified_powershell." + filepath.split(".")[-1]

     squiggly_count = 0

     with open(filepath, "r") as fileread:
          with open(filetowrite, "w") as filewrite:
               logging.debug(f"Writing prettified file: {filetowrite}")
               for line in fileread:
                    for i, c in enumerate(line):
                         # for each opening squiqelly bracket, print it, then increment the bracket count
                         # and print a new line and the correct number of tabs
                         if c == "{":
                              filewrite.write(c)
                              squiggly_count += 1
                              filewrite.write("\n" + squiggly_count * "\t")
                              continue
                         # for each closing squiqqly bracket, decrement the bracket count,
                         # print a new line and the correct number of tabs, then the bracket, than a new line
                         elif c == "}":
                              squiggly_count -= 1
                              filewrite.write("\n" + squiggly_count * "\t" + c + "\n")
                              if squiggly_count == 0:
                                   filewrite.write("\n")
                              continue
                         # for each semicolon, print it followed by a new line and the correct number of tabs
                         elif c == ";":
                              filewrite.write(c)
                              if line[i + 1] != "}":
                                   filewrite.write("\n" + squiggly_count * "\t")
                              if squiggly_count == 0:
                                   filewrite.write("\n")
                              continue
                         # for each space, if it follows a semicolon, do not print it. This is because it will
                         # mess up the indentation
                         elif c == " ":
                              if line[i - 1] == ";":
                                   continue
                         filewrite.write(c)
                         continue
               filewrite.close()
               fileread.close()


def check_enabledelayedexpansion(line, enabledelayedexpansion):
     if b"enabledelayedexpansion" in line:
          enabledelayedexpansion = True
          logging.debug("enabledelayedexpansion set to True.")
     return line, enabledelayedexpansion

def replace_exclamation(line, enabledelayedexpansion):
     # As stated here https://stackoverflow.com/questions/22041586/windows-batch-file-syntax-using-exclamation-mark
     # When you enable delayed expansion and change or set a variable within a loop
     # then the !variable! syntax allows you to use the variable within the loop.
     # This function performs such transformation if delayedexpansion has been enabled.
     if enabledelayedexpansion:
          # perform  transformations of the form !<var>!
          if re.search(REGEX_EXCLAMATION, line):
               matches = re.findall(REGEX_EXCLAMATION, line)
               #logging.debug("REGEX_EXCLAMATION found a match.")
               for i in matches:
                    try:
                         line = line.replace(b"!" + i + b"!", vars[i])
                         logging.debug(f"Performing an exclamation replacement. Replaced {i} with {vars[i]}")
                    except KeyError:
                         line = line.replace(b"!" + i + b"!", b"")
                         continue
     return line, enabledelayedexpansion

def main():
     filepath, filetowrite, filetowrite_comment = parse_args()
     open_file(filepath)
     with open(filetowrite, "w") as filewrite:
          with open(filetowrite_comment, "w") as filewrite_comment:
               enabledelayedexpansion = False
               for y in range(len(lines)):
                    write_line = True
                    if not file_is_binary:
                         lines[y] = bytes(lines[y], "utf-8")
                    #logging.debug(f"Line pre-deobfuscation is: {lines[y]}")
                    lines[y], comment_line = initial_cleanup(lines[y])
                    lines[y] = replace_index(lines[y])
                    lines[y] = replace_substring(lines[y])
                    lines[y] = replace_direct(lines[y])
                    lines[y], enabledelayedexpansion = check_enabledelayedexpansion(lines[y], enabledelayedexpansion)
                    lines[y], enabledelayedexpansion = replace_exclamation(lines[y], enabledelayedexpansion)
                    #logging.debug(f"Line post-deobfuscation is: {lines[y]}")
                    lines[y], write_line = set_env_variables(lines[y])
                    write_text(filewrite, lines[y], comment_line, filewrite_comment, write_line)
               logging.debug(f"Writing deobfuscated file: {filetowrite}")
               logging.debug(f"Writing file containing comments (i.e., potential payloads): {filetowrite_comment}")
               filewrite.close()
               prettify(filetowrite)

if __name__ == "__main__":
    main()