#! /usr/bin/env python


'''
This script defangs a VBS script by:
- commenting out any calls to ...execute(...) and writing logic to output its parameters to a file when the vbs script is run

See this comment for a good differentiation between:
- function(params)
- call function(params)
- function params

- TODO: logic to handle calls to ExecuteGlobal statement: https://www.vbsedit.com/html/25ebfa26-d3b9-4f82-b3c9-a8568a389dbc.asp
- TODO: logic to handle calls to object.Run(strCommand, [intWindowStyle], [bWaitOnReturn]): https://www.vbsedit.com/html/6f28899c-d653-4555-8a59-49640b0e32ea.asp
- TODO: add debug messages for interesting strings such as createobject, 
'''

from argparse import ArgumentParser
import re
import os
import sys
import ntpath
import logging, sys

logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

# regex to capture calls to execute(params) functions
REGEX_EXECUTE_BRACKETS = b"execute\(([^,]+),?([^,^,]+)?,?([^,^,^,]+)?,?([^,^,^,^,]+)?,?([^)]+)\)"
# regex to capture calls to execute params functions
REGEX_RUN_SPACE = b"execute ([^,\n]+),?([^,\n^,]+)?,?([^,\n^,^,]+)?,?([^,\n^,^,^,]+)?,?([^\n]+)"
# regex to capture calls to .run(params) functions
REGEX_RUN_BRACKETS = b".run\(([^,]+),?([^,^,]+)?,?([^,^,^,]+)?,?([^,^,^,^,]+)?,?([^)]+)\)"
# regex to capture calls to .run params functions
REGEX_RUN_SPACE = b".run ([^,\n]+),?([^,\n^,]+)?,?([^,\n^,^,]+)?,?([^,\n^,^,^,]+)?,?([^\n]+)"

def parse_args():
     parser = ArgumentParser('VBS (.vbs) File Defanger', 'Defangs a batch file by replacing execute calls with echo statements.')
     parser.add_argument('-f', '--filepath', type=os.path.abspath, required=True, help='VBS (.vbs) file to deobfuscate')
     args = parser.parse_args()
     filepath = args.filepath
     filetowrite = filepath.split('.')[0] + '_defanged.' + filepath.split('.')[-1]
     return filepath, filetowrite

def open_file(filepath):
     logging.debug(f"Attempting to read the input file: {filepath}")
     global file_is_binary
     file_is_binary = False
     try:
          with open(filepath, 'r') as fileread:
               global lines
               lines = fileread.readlines()
               fileread.close()
     except UnicodeDecodeError:
          file_is_binary = True
          print(b"Binary File Identified")
          with open(filepath, 'rb') as fileread:
               lines = fileread.readlines()
               fileread.close()
     if fileread:
          logging.debug("Input file read.")

def initial_cleanup(line):
     # easier to deal with everything in one case, and strip any trailing new lines
     # which Python's readline() sometimes adds
     line = line.lower().rstrip(b"\n")
     # Some files will have null bytes added for obfuscation, so remove these
     line = line.replace(b"\x00", b"")
     # skip any comment lines, as these can be lengthy if they include payloads,
     # which makes reading the deobfuscated file more difficult
     if line.startswith(b"'"):
          line = b""
          #logging.debug("Line starts with ', i.e., is a comment line.")
          return line
     return line


def replace_execute(line):
     original_line = line
     if re.search(REGEX_EXECUTE_BRACKETS, line):
          grps = re.search(REGEX_EXECUTE_BRACKETS, line)
          print(grps)
          for i in range(1, len(grps.groups())):
               print(grps.group(i))
               try:
                    param = grps.group(i)
                    # some parameters are empty/spaces - these will lead to errors when running
                    # the vbs file using wine, so we ignore these
                    if grps.group(i).isspace():
                         param = "space"
                    line = line + b"\r\n" + b"WScript.Echo " + param + b" & vbCrLf"
                    line = line + b"\r\n" + b"objFile.Write " + param + b" & vbCrLf"
               except (KeyError, TypeError, AttributeError) as e:
                    continue
          line = b"'" + line
          logging.debug(f"Replaced {original_line} with {line}")
     if re.search(REGEX_RUN_SPACE, line):
          grps = re.search(REGEX_RUN_SPACE, line)
          print(grps)
          for i in range(1, len(grps.groups())):
               print(grps.group(i))
               try:
                    param = grps.group(i)
                    if grps.group(i).isspace():
                         param = "space"
                    line = line + b"\r\n" + b"WScript.Echo " + param + b" & vbCrLf"
                    line = line + b"\r\n" + b"objFile.Write " + param + b" & vbCrLf"
               except (KeyError, TypeError, AttributeError) as e:
                    continue
          line = b"'" + line
          logging.debug(f"Replaced {original_line} with {line}")
     return line

def replace_run(line):
     original_line = line
     if re.search(REGEX_RUN_BRACKETS, line):
          grps = re.search(REGEX_RUN_BRACKETS, line)
          print(grps)
          for i in range(1, len(grps.groups())):
               print(grps.group(i))
               try:
                    param = grps.group(i)
                    if grps.group(i).isspace():
                         param = "space"
                    line = line + b"\r\n" + b"WScript.Echo " + param + b" & vbCrLf"
                    line = line + b"\r\n" + b"objFile.Write " + param + b" & vbCrLf"
               except (KeyError, TypeError, AttributeError) as e:
                    continue
          line = b"'" + line
          logging.debug(f"Replaced {original_line} with {line}")
     if re.search(REGEX_RUN_SPACE, line):
          grps = re.search(REGEX_RUN_SPACE, line)
          print(grps)
          for i in range(1, len(grps.groups())):
               print(grps.group(i))
               try:
                    param = grps.group(i)
                    if grps.group(i).isspace():
                         param = "space"
                    line = line + b"\r\n" + b"WScript.Echo " + param + b" & vbCrLf"
                    line = line + b"\r\n" + b"objFile.Write " + param + b" & vbCrLf"
               except (KeyError, TypeError, AttributeError) as e:
                    continue
          line = b"'" + line
          logging.debug(f"Replaced {original_line} with {line}")
     return line

def write_text(filewrite, line, write_line ):
     if write_line and not line.isspace():
          # we don't want to write any unicode characters, as these should have all been deobfuscated anyway.
          # Any remaining unicode characters may be present as part of set commands (where the variable is in unicode),
          # but we don't want to print those anyway. 
          try:
               filewrite.write(line.decode("utf-8"))
               # print a new line so the results are more easily readable
               filewrite.write("\r\n")
               #logging.debug(f"Line written: {line}")
          except UnicodeDecodeError:
               return


def main():
     filepath, filetowrite = parse_args()
     open_file(filepath)
     with open(filetowrite, "w") as filewrite:
          # because wscript.echo generates a message box when ran using wscript, which is the
          # default in win it seems, output the parameters to execute to a file instead.
          # https://stackoverflow.com/questions/2198810/creating-and-writing-lines-to-a-file
          filewrite.write("Set objFSO=CreateObject(\"Scripting.FileSystemObject\")\r\n")
          filewrite.write("outFile=\"defanged_vbs_results.txt\"\r\n")
          filewrite.write("Set objFile = objFSO.CreateTextFile(outFile,True)\r\n")
          for y in range(len(lines)):
               write_line = True
               if not file_is_binary:
                    lines[y] = bytes(lines[y], "utf-8")
               lines[y] = initial_cleanup(lines[y])
               lines[y] = replace_execute(lines[y])
               lines[y] = replace_run(lines[y])
               write_text(filewrite, lines[y], write_line)
               #logging.debug(f"Line: {lines[y]}")
          filewrite.write("objFile.Close\r\n")
          logging.debug(f"Writing defanged file: {filetowrite}")
          filewrite.close()

if __name__ == "__main__":
    main()